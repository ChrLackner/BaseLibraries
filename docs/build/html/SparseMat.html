<!DOCTYPE html>
<html class="writer-html5" lang="ja" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>SparseMat &mdash; BaseLibrariesPages  ドキュメント</title>
      <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="_static/jquery.js"></script>
        <script src="_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
        <script src="_static/doctools.js"></script>
        <script src="_static/sphinx_highlight.js"></script>
        <script src="_static/translations.js"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="索引" href="genindex.html" />
    <link rel="search" title="検索" href="search.html" />
    <link rel="next" title="利用例" href="UserSample.html" />
    <link rel="prev" title="BasicFuncs" href="BaseLibraries.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="index.html" class="icon icon-home">
            BaseLibrariesPages
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="GetStart.html">[基本的な使い方]</a></li>
<li class="toctree-l1"><a class="reference internal" href="Basic.html">基本ヘッダ</a></li>
<li class="toctree-l1"><a class="reference internal" href="BaseLibraries.html">BasicFuncs</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">SparseMat</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#id1">SparseMatクラス</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id2">* 基本操作</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id3">SparseMat();</a></li>
<li class="toctree-l4"><a class="reference internal" href="#sparsemat-slv-int-x">SparseMat(slv_int x);</a></li>
<li class="toctree-l4"><a class="reference internal" href="#sparsemat-const-sparsemat-mat">SparseMat(const SparseMat&amp; mat);</a></li>
<li class="toctree-l4"><a class="reference internal" href="#bool-isfixed">bool isFixed()</a></li>
<li class="toctree-l4"><a class="reference internal" href="#bool-isempty-const">bool isEmpty() const</a></li>
<li class="toctree-l4"><a class="reference internal" href="#void-tempinitialize">void tempInitialize()</a></li>
<li class="toctree-l4"><a class="reference internal" href="#void-fix">void fix()</a></li>
<li class="toctree-l4"><a class="reference internal" href="#void-resetmat">void resetMat()</a></li>
<li class="toctree-l4"><a class="reference internal" href="#void-add-slv-int-gyo-slv-int-retu-double-val">void add(slv_int gyo, slv_int retu, double val)</a></li>
<li class="toctree-l4"><a class="reference internal" href="#slv-int-isinclude-slv-int-gyo-slv-int-target-r-const">slv_int isInclude(slv_int gyo, slv_int target_r)const</a></li>
<li class="toctree-l4"><a class="reference internal" href="#void-gettargetrowval-slv-int-target-std-vector-slv-int-row-pos-std-vector-row-val-const">void getTargetRowVal(slv_int target, std::vector&lt;slv_int&gt;&amp; row_pos, std::vector<double>&amp; row_val)const</a></li>
<li class="toctree-l4"><a class="reference internal" href="#void-gettargetcolval-slv-int-target-std-vector-slv-int-col-pos-std-vector-col-val-const">void getTargetColVal(slv_int target, std::vector&lt;slv_int&gt;&amp; col_pos, std::vector<double>&amp; col_val)const</a></li>
<li class="toctree-l4"><a class="reference internal" href="#void-printmat-const-std-string-str-mat-csv">void printMat(const std::string&amp; str=&quot;Mat.csv&quot;)</a></li>
<li class="toctree-l4"><a class="reference internal" href="#void-print">void print()</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#id4">* オペレータ群</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#double-operator-const-double-vec-const">double* operator*(const double* vec) const;</a></li>
<li class="toctree-l4"><a class="reference internal" href="#dcomplex-operator-const-dcomplex-vec-const">dcomplex* operator*(const dcomplex* vec) const;</a></li>
<li class="toctree-l4"><a class="reference internal" href="#eigen-vectorxd-operator-const-eigen-vectorxd-vec-const">Eigen::VectorXd operator*(const Eigen::VectorXd&amp; vec) const;</a></li>
<li class="toctree-l4"><a class="reference internal" href="#eigen-vectorxcd-operator-const-eigen-vectorxcd-vec-const">Eigen::VectorXcd operator*(const Eigen::VectorXcd&amp; vec) const;</a></li>
<li class="toctree-l4"><a class="reference internal" href="#void-operator-const-double-x">void operator*=(const double x)</a></li>
<li class="toctree-l4"><a class="reference internal" href="#sparsemat-operator-const-double-x-const">SparseMat operator*(const double x) const;</a></li>
<li class="toctree-l4"><a class="reference internal" href="#sparsematc-operator-const-dcomplex-x-const">SparseMatC operator*(const dcomplex x) const;</a></li>
<li class="toctree-l4"><a class="reference internal" href="#sparsemat-operator-const-sparsemat-mat-const">SparseMat operator*(const SparseMat&amp; mat) const;</a></li>
<li class="toctree-l4"><a class="reference internal" href="#sparsematc-operator-const-sparsematc-mat-const">SparseMatC operator*(const SparseMatC&amp; mat) const;</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id5">SparseMat operator+(const SparseMat&amp; mat) const;</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id6">SparseMatC operator+(const SparseMatC&amp; mat) const;</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#id7">* その他の行列オペレータ群</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#sparsemat-trans-const">SparseMat trans() const</a></li>
<li class="toctree-l4"><a class="reference internal" href="#sparsemat-makesubmat-slv-int-range1a-slv-int-range1b-slv-int-range2a-slv-int-range2b">SparseMat makeSubMat(slv_int range1a, slv_int range1b, slv_int range2a, slv_int range2b)</a></li>
<li class="toctree-l4"><a class="reference internal" href="#void-matdiv-sparsemat-matk11-sparsemat-matk12-slv-int-rangea-slv-int-rangeb">void MatDiv(SparseMat&amp; matK11, SparseMat&amp; matK12, slv_int rangeA, slv_int rangeB)</a></li>
<li class="toctree-l4"><a class="reference internal" href="#sparsemat-getmatlower-const">SparseMat getMatLower() const;</a></li>
<li class="toctree-l4"><a class="reference internal" href="#sparsemat-getmatupper-const">SparseMat getMatUpper() const</a></li>
<li class="toctree-l4"><a class="reference internal" href="#sparsemat-inv-const">SparseMat inv() const</a></li>
<li class="toctree-l4"><a class="reference internal" href="#void-round">void round()</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#sparsematc">SparseMatCクラス</a></li>
<li class="toctree-l2"><a class="reference internal" href="#sparsematoperators">SparseMatOperatorsクラス</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#static-sparsemat-plusshift-const-sparsemat-mat1-const-sparsemat-mat2-const-double-a1-const-double-a2-const-slv-int-pos1-const-slv-int-pos2">static SparseMat plusShift(const SparseMat&amp; mat1, const SparseMat&amp; mat2, const double a1, const double a2, const slv_int pos1, const slv_int pos2)</a></li>
<li class="toctree-l3"><a class="reference internal" href="#static-sparsematc-plusshift-const-sparsematc-mat1-const-sparsematc-mat2-const-double-a1-const-double-a2-const-slv-int-pos1-const-slv-int-pos2">static SparseMatC plusShift(const SparseMatC&amp; mat1, const SparseMatC&amp; mat2, const double a1, const double a2, const slv_int pos1, const slv_int pos2)</a></li>
<li class="toctree-l3"><a class="reference internal" href="#static-double-dotvecmat2-const-sparsemat-mat1-const-sparsemat-mat2-const-double-vec1">static double* dotVecMat2(const SparseMat&amp; mat1, const SparseMat&amp; mat2, const double* vec1);</a></li>
<li class="toctree-l3"><a class="reference internal" href="#static-dcomplex-dotvecmat2-const-sparsemat-mat1-const-sparsematc-mat2-const-double-vec1">static dcomplex* dotVecMat2(const SparseMat&amp; mat1, const SparseMatC&amp; mat2, const double* vec1);</a></li>
<li class="toctree-l3"><a class="reference internal" href="#static-dcomplex-dotvecmat2-const-sparsematc-mat1-const-sparsemat-mat2-const-double-vec1">static dcomplex* dotVecMat2(const SparseMatC&amp; mat1, const SparseMat&amp; mat2, const double* vec1);</a></li>
<li class="toctree-l3"><a class="reference internal" href="#static-dcomplex-dotvecmat2-const-sparsematc-mat1-const-sparsematc-mat2-const-double-vec1">static dcomplex* dotVecMat2(const SparseMatC&amp; mat1, const SparseMatC&amp; mat2, const double* vec1);</a></li>
<li class="toctree-l3"><a class="reference internal" href="#static-dcomplex-dotvecmat2-const-sparsemat-mat1-const-sparsemat-mat2-const-dcomplex-vec1">static dcomplex* dotVecMat2(const SparseMat&amp; mat1, const SparseMat&amp; mat2, const dcomplex* vec1);</a></li>
<li class="toctree-l3"><a class="reference internal" href="#static-dcomplex-dotvecmat2-const-sparsemat-mat1-const-sparsematc-mat2-const-dcomplex-vec1">static dcomplex* dotVecMat2(const SparseMat&amp; mat1, const SparseMatC&amp; mat2, const dcomplex* vec1);</a></li>
<li class="toctree-l3"><a class="reference internal" href="#static-dcomplex-dotvecmat2-const-sparsematc-mat1-const-sparsemat-mat2-const-dcomplex-vec1">static dcomplex* dotVecMat2(const SparseMatC&amp; mat1, const SparseMat&amp; mat2, const dcomplex* vec1);</a></li>
<li class="toctree-l3"><a class="reference internal" href="#static-dcomplex-dotvecmat2-const-sparsematc-mat1-const-sparsematc-mat2-const-dcomplex-vec1">static dcomplex* dotVecMat2(const SparseMatC&amp; mat1, const SparseMatC&amp; mat2, const dcomplex* vec1);</a></li>
<li class="toctree-l3"><a class="reference internal" href="#static-sparsemat-dotmats-const-sparsemat-mata-const-sparsemat-matb-const-sparsemat-matc">static SparseMat dotMats(const SparseMat&amp; matA, const SparseMat&amp; matB, const SparseMat&amp; matC);</a></li>
<li class="toctree-l3"><a class="reference internal" href="#static-sparsematc-dotmats-const-sparsemat-mata-const-sparsemat-matb-const-sparsematc-matc">static SparseMatC dotMats(const SparseMat&amp; matA, const SparseMat&amp; matB, const SparseMatC&amp; matC);</a></li>
<li class="toctree-l3"><a class="reference internal" href="#static-sparsematc-dotmats-const-sparsemat-mata-const-sparsematc-matb-const-sparsematc-matc">static SparseMatC dotMats(const SparseMat&amp; matA, const SparseMatC&amp; matB, const SparseMatC&amp; matC);</a></li>
<li class="toctree-l3"><a class="reference internal" href="#static-sparsematc-dotmats-const-sparsematc-mata-const-sparsematc-matb-const-sparsematc-matc">static SparseMatC dotMats(const SparseMatC&amp; matA, const SparseMatC&amp; matB, const SparseMatC&amp; matC);</a></li>
<li class="toctree-l3"><a class="reference internal" href="#static-void-plusfix-sparsemat-matab-const-sparsemat-mata-const-sparsemat-matb-double-a1-1-0-double-a2-1-0-slv-int-pos1-0-slv-int-pos2-0">static void plusFix(SparseMat&amp; matAB, const SparseMat&amp; matA, const SparseMat&amp; matB, double a1=1.0, double a2=1.0, slv_int pos1=0, slv_int pos2=0);</a></li>
<li class="toctree-l3"><a class="reference internal" href="#static-void-plusfix-sparsematc-matab-const-sparsemat-mata-const-sparsematc-matb-double-a1-1-0-double-a2-1-0-slv-int-pos1-0-slv-int-pos2-0">static void plusFix(SparseMatC&amp; matAB, const SparseMat&amp; matA, const SparseMatC&amp; matB, double a1=1.0, double a2=1.0, slv_int pos1=0, slv_int pos2=0);</a></li>
<li class="toctree-l3"><a class="reference internal" href="#static-void-plusfix-sparsematc-matab-const-sparsematc-mata-const-sparsematc-matb-double-a1-1-0-double-a2-1-0-slv-int-pos1-0-slv-int-pos2-0">static void plusFix(SparseMatC&amp; matAB, const SparseMatC&amp; matA, const SparseMatC&amp; matB, double a1=1.0, double a2=1.0, slv_int pos1=0, slv_int pos2=0);</a></li>
<li class="toctree-l3"><a class="reference internal" href="#static-void-plusfix-sparsemat-matabc-const-sparsemat-mata-const-sparsemat-matb-const-sparsemat-matc-double-a1-1-0-double-a2-1-0-double-a3-1-0">static void plusFix(SparseMat&amp; matABC, const SparseMat&amp; matA, const SparseMat&amp; matB, const SparseMat&amp; matC, double a1=1.0, double a2=1.0, double a3=1.0);</a></li>
<li class="toctree-l3"><a class="reference internal" href="#static-void-plusfix-sparsematc-matabc-const-sparsematc-mata-const-sparsematc-matb-const-sparsematc-matc-double-a1-1-0-double-a2-1-0-double-a3-1-0">static void plusFix(SparseMatC&amp; matABC, const SparseMatC&amp; matA, const SparseMatC&amp; matB, const SparseMatC&amp; matC, double a1=1.0, double a2=1.0, double a3=1.0);</a></li>
<li class="toctree-l3"><a class="reference internal" href="#static-void-dotfix-sparsemat-matab-const-sparsemat-mata-const-sparsemat-matb">static void dotFix(SparseMat&amp; matAB, const SparseMat&amp; matA, const SparseMat&amp; matB);</a></li>
<li class="toctree-l3"><a class="reference internal" href="#static-void-dotfix-sparsematc-matab-const-sparsemat-mata-const-sparsematc-matb">static void dotFix(SparseMatC&amp; matAB, const SparseMat&amp; matA, const SparseMatC&amp; matB);</a></li>
<li class="toctree-l3"><a class="reference internal" href="#static-void-dotfix-sparsematc-matab-const-sparsematc-mata-const-sparsematc-matb">static void dotFix(SparseMatC&amp; matAB, const SparseMatC&amp; matA, const SparseMatC&amp; matB);</a></li>
<li class="toctree-l3"><a class="reference internal" href="#static-void-dotfix-sparsemat-matab-const-sparsemat-mata-const-sparsemat-matb-const-sparsemat-matc">static void dotFix(SparseMat&amp; matAB, const SparseMat&amp; matA, const SparseMat&amp; matB, const SparseMat&amp; matC);</a></li>
<li class="toctree-l3"><a class="reference internal" href="#static-void-dotfix-sparsematc-matab-const-sparsemat-mata-const-sparsemat-matb-const-sparsematc-matc">static void dotFix(SparseMatC&amp; matAB, const SparseMat&amp; matA, const SparseMat&amp; matB, const SparseMatC&amp; matC);</a></li>
<li class="toctree-l3"><a class="reference internal" href="#static-void-dotfix-sparsematc-matab-const-sparsemat-mata-const-sparsematc-matb-const-sparsematc-matc">static void dotFix(SparseMatC&amp; matAB, const SparseMat&amp; matA, const SparseMatC&amp; matB, const SparseMatC&amp; matC);</a></li>
<li class="toctree-l3"><a class="reference internal" href="#static-void-dotfix-sparsematc-matab-const-sparsematc-mata-const-sparsematc-matb-const-sparsematc-matc">static void dotFix(SparseMatC&amp; matAB, const SparseMatC&amp; matA, const SparseMatC&amp; matB, const SparseMatC&amp; matC);</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#matsolvers">MatSolversクラス</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id8">static SparseMat plusShift(const SparseMat&amp; mat1, const SparseMat&amp; mat2, const double a1, const double a2, const slv_int pos1, const slv_int pos2)</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id9">static SparseMatC plusShift(const SparseMatC&amp; mat1, const SparseMatC&amp; mat2, const double a1, const double a2, const slv_int pos1, const slv_int pos2)</a></li>
<li class="toctree-l3"><a class="reference internal" href="#static-bool-solveiccg-const-slv-int-size0-const-double-conv-cri-const-int-max-ite-const-double-accera-const-sparsemat-mata-const-double-vecb-double-results-bool-init-false">static bool solveICCG(const slv_int size0, const double conv_cri, const int max_ite, const double accera, const SparseMat&amp; matA, const double *vecB, double *results, bool init=false)</a></li>
<li class="toctree-l3"><a class="reference internal" href="#static-bool-solveiccg-const-slv-int-size0-const-double-conv-cri-const-int-max-ite-const-double-accera-const-double-normb-const-sparsemat-mata-const-double-vecb-double-results-bool-init-false">static bool solveICCG(const slv_int size0, const double conv_cri, const int max_ite, const double accera, const double normB, const SparseMat&amp; matA, const double *vecB, double *results, bool init=false)</a></li>
<li class="toctree-l3"><a class="reference internal" href="#static-bool-solveiccg-const-slv-int-size0-const-double-conv-cri-const-int-max-ite-const-double-accera-const-sparsemat-mata-const-eigen-vectorxd-vecb-double-results-bool-init-false">static bool solveICCG(const slv_int size0, const double conv_cri, const int max_ite, const double accera, const SparseMat&amp; matA, const Eigen::VectorXd&amp; vecB, double *results, bool init=false)</a></li>
<li class="toctree-l3"><a class="reference internal" href="#static-bool-solveiccg-slv-int-size0-const-double-conv-cri-const-int-max-ite-const-double-accera-const-sparsematc-mata-const-dcomplex-vecb-dcomplex-results-bool-init-false">static bool solveICCG(slv_int size0, const double conv_cri, const int max_ite, const double accera, const SparseMatC&amp; matA, const dcomplex *vecB, dcomplex *results, bool init=false);</a></li>
<li class="toctree-l3"><a class="reference internal" href="#static-bool-solveiccg-slv-int-size0-const-double-conv-cri-const-int-max-ite-const-double-accera-const-double-normb-const-sparsematc-mata-const-dcomplex-vecb-dcomplex-results-bool-init-false">static bool solveICCG(slv_int size0, const double conv_cri, const int max_ite, const double accera, const double normB, const SparseMatC&amp; matA, const dcomplex *vecB, dcomplex *results, bool init=false);</a></li>
<li class="toctree-l3"><a class="reference internal" href="#static-bool-solveiccg-slv-int-size0-const-double-conv-cri-const-int-max-ite-const-double-accera-const-sparsematc-mata-const-eigen-vectorxcd-vecb-dcomplex-results-bool-init-false">static bool solveICCG(slv_int size0, const double conv_cri, const int max_ite, const double accera, const SparseMatC&amp; matA, const Eigen::VectorXcd&amp; vecB, dcomplex *results, bool init=false);</a></li>
<li class="toctree-l3"><a class="reference internal" href="#static-bool-solveeigeniccg-const-slv-int-size0-const-double-conv-cri-const-int-max-ite-const-sparsemat-mata-const-eigen-vectorxd-vecb-eigen-vectorxd-results-bool-init-false">static bool solveEigenICCG(const slv_int size0, const double conv_cri, const int max_ite, const SparseMat&amp; matA, const Eigen::VectorXd&amp; vecB, Eigen::VectorXd&amp; results, bool init=false);</a></li>
<li class="toctree-l3"><a class="reference internal" href="#static-bool-solveeigeniccg-const-slv-int-size0-const-double-conv-cri-const-int-max-ite-const-sparsemat-mata-const-double-vecb-double-results-bool-init-true">static bool solveEigenICCG(const slv_int size0, const double conv_cri, const int max_ite, const SparseMat&amp; matA, const double* vecB, double* results, bool init=true);</a></li>
<li class="toctree-l3"><a class="reference internal" href="#static-bool-solveeigenbicgstab-const-slv-int-size0-const-double-conv-cri-const-int-max-ite-const-sparsemat-mata-const-eigen-vectorxd-vecb-eigen-vectorxd-results-bool-init-false">static bool solveEigenBiCGstab(const slv_int size0, const double conv_cri, const int max_ite, const SparseMat&amp; matA, const Eigen::VectorXd&amp; vecB, Eigen::VectorXd&amp; results, bool init=false);</a></li>
<li class="toctree-l3"><a class="reference internal" href="#static-bool-solveeigenbicgstab-const-slv-int-size0-const-double-conv-cri-const-int-max-ite-const-sparsemat-mata-const-double-vecb-double-results-bool-init-true">static bool solveEigenBiCGstab(const slv_int size0, const double conv_cri, const int max_ite, const SparseMat&amp; matA, const double* vecB, double* results, bool init=true);</a></li>
<li class="toctree-l3"><a class="reference internal" href="#static-bool-solveeigeniccg-const-slv-int-size0-const-double-conv-cri-const-int-max-ite-const-sparsematc-mata-const-eigen-vectorxcd-vecb-eigen-vectorxcd-results-bool-init-false">static bool solveEigenICCG(const slv_int size0, const double conv_cri, const int max_ite, const SparseMatC&amp; matA, const Eigen::VectorXcd&amp; vecB, Eigen::VectorXcd&amp; results, bool init=false);</a></li>
<li class="toctree-l3"><a class="reference internal" href="#static-bool-solveeigeniccg-const-slv-int-size0-const-double-conv-cri-const-int-max-ite-const-sparsematc-mata-const-dcomplex-vecb-dcomplex-results-bool-init-true">static bool solveEigenICCG(const slv_int size0, const double conv_cri, const int max_ite, const SparseMatC&amp; matA, const dcomplex* vecB, dcomplex* results, bool init=true);</a></li>
<li class="toctree-l3"><a class="reference internal" href="#static-bool-solveeigenbicgstab-const-slv-int-size0-const-double-conv-cri-const-int-max-ite-const-sparsematc-mata-const-eigen-vectorxcd-vecb-eigen-vectorxcd-results-bool-init-false">static bool solveEigenBiCGstab(const slv_int size0, const double conv_cri, const int max_ite, const SparseMatC&amp; matA, const Eigen::VectorXcd&amp; vecB, Eigen::VectorXcd&amp; results, bool init=false);</a></li>
<li class="toctree-l3"><a class="reference internal" href="#static-bool-solveeigenbicgstab-const-slv-int-size0-const-double-conv-cri-const-int-max-ite-const-sparsematc-mata-const-dcomplex-vecb-dcomplex-results-bool-init-false">static bool solveEigenBiCGstab(const slv_int size0, const double conv_cri, const int max_ite, const SparseMatC&amp; matA,  const dcomplex* vecB, dcomplex* results, bool init=false);</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="UserSample.html">利用例</a></li>
<li class="toctree-l1"><a class="reference internal" href="ForDev.html">開発者向け</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">BaseLibrariesPages</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">SparseMat</li>
      <li class="wy-breadcrumbs-aside">
            <a href="_sources/SparseMat.md.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="sparsemat">
<h1>SparseMat<a class="headerlink" href="#sparsemat" title="この見出しへのパーマリンク"></a></h1>
<p>有限要素法で使う疎行列用ライブラリです。
本ライブラリのstaticライブラリファイルは <strong>「SparseMat.lib」</strong> です。</p>
<p>EigenのEigen::SparseMatrixをベースとして作成されており、Eigenの疎行列ラッパーとして機能します。
double型、complex型の両方に対応し、疎行列の四則演算なども用意されています。
ソルバとしては、オリジナルの加速係数つきICCGソルバが用意されています。
その他、Eigenが用意しているICCGとBiCGstabのラッパも用意しています。</p>
<p>内部のintは、slv_intとして別の型として定義しています。</p>
<p>・using slv_int = int;　(SparseMatTMPL.hppの冒頭)</p>
<p>基本はこのままでいいと思いますが、超大規模にしたい場合はunsingedやlong intに書き換えてください</p>
<hr class="docutils" />
<hr class="docutils" />
<section id="id1">
<h2>SparseMatクラス<a class="headerlink" href="#id1" title="この見出しへのパーマリンク"></a></h2>
<p>実数用の疎行列クラスです。
基本的には、まず初期化した後、add関数で行列要素を追加していきます。
追加が完了したら、fixメソッドで疎行列を確定させてください。
確定後にメソッドや四則演算が行えます。fix前に各種操作を行うとエラーになる恐れがあるので注意してください。
「SparseMat/SparseMat.hpp」をインクルードして使ってください。</p>
<section id="id2">
<h3>* 基本操作<a class="headerlink" href="#id2" title="この見出しへのパーマリンク"></a></h3>
<hr class="docutils" />
<section id="id3">
<h4>SparseMat();<a class="headerlink" href="#id3" title="この見出しへのパーマリンク"></a></h4>
<p>コンストラクタ：疎行列を初期化します。インスタンスが作成されるだけで内部は何も初期化されません。
この状態でaddをしてもエラーになります。</p>
</section>
<section id="sparsemat-slv-int-x">
<h4>SparseMat(slv_int x);<a class="headerlink" href="#sparsemat-slv-int-x" title="この見出しへのパーマリンク"></a></h4>
<p>コンストラクタ：疎行列を初期化します。行数サイズをxで初期化します。
（内部でtempInitializeを呼び、初期化します）</p>
</section>
<section id="sparsemat-const-sparsemat-mat">
<h4>SparseMat(const SparseMat&amp; mat);<a class="headerlink" href="#sparsemat-const-sparsemat-mat" title="この見出しへのパーマリンク"></a></h4>
<p>コンストラクタ：別の疎行列を代入して初期化します。本方法で初期化すると最初からfix状態になります。</p>
</section>
<section id="bool-isfixed">
<h4>bool isFixed()<a class="headerlink" href="#bool-isfixed" title="この見出しへのパーマリンク"></a></h4>
<p>呼び出し元インスタンスが確定済み(fixを呼び出した後か)かどうかを返します。</p>
</section>
<section id="bool-isempty-const">
<h4>bool isEmpty() const<a class="headerlink" href="#bool-isempty-const" title="この見出しへのパーマリンク"></a></h4>
<p>行列の中身が空かどうかを返します。</p>
</section>
<section id="void-tempinitialize">
<h4>void tempInitialize()<a class="headerlink" href="#void-tempinitialize" title="この見出しへのパーマリンク"></a></h4>
<p>疎行列の状況を初期化し、fixされていない状態にします。</p>
</section>
<section id="void-fix">
<h4>void fix()<a class="headerlink" href="#void-fix" title="この見出しへのパーマリンク"></a></h4>
<p>疎行列を確定させます。</p>
</section>
<section id="void-resetmat">
<h4>void resetMat()<a class="headerlink" href="#void-resetmat" title="この見出しへのパーマリンク"></a></h4>
<p>fix済みの疎行列の０にします。
（疎行列の位置はそのまま、値だけゼロにします）</p>
</section>
<section id="void-add-slv-int-gyo-slv-int-retu-double-val">
<h4>void add(slv_int gyo, slv_int retu, double val)<a class="headerlink" href="#void-add-slv-int-gyo-slv-int-retu-double-val" title="この見出しへのパーマリンク"></a></h4>
<p>疎行列の指定の位置に値を加えます。行の位置をgyoで、列の位置をretuで指定し、そこにValを加えます。
fix前の場合は任意の位置にaddできます。
fix後は、すでに値のある位置以外を指定するとエラーになります。</p>
</section>
<section id="slv-int-isinclude-slv-int-gyo-slv-int-target-r-const">
<h4>slv_int isInclude(slv_int gyo, slv_int target_r)const<a class="headerlink" href="#slv-int-isinclude-slv-int-gyo-slv-int-target-r-const" title="この見出しへのパーマリンク"></a></h4>
<p>疎行列のi行目に、target_r列があるかどうかを判定します。あったらそのindexを返します。</p>
</section>
<section id="void-gettargetrowval-slv-int-target-std-vector-slv-int-row-pos-std-vector-row-val-const">
<h4>void getTargetRowVal(slv_int target, std::vector&lt;slv_int&gt;&amp; row_pos, std::vector<double>&amp; row_val)const<a class="headerlink" href="#void-gettargetrowval-slv-int-target-std-vector-slv-int-row-pos-std-vector-row-val-const" title="この見出しへのパーマリンク"></a></h4>
<p>指定した列の非ゼロの行位置と値をvector「row_val」にコピーします。</p>
</section>
<section id="void-gettargetcolval-slv-int-target-std-vector-slv-int-col-pos-std-vector-col-val-const">
<h4>void getTargetColVal(slv_int target, std::vector&lt;slv_int&gt;&amp; col_pos, std::vector<double>&amp; col_val)const<a class="headerlink" href="#void-gettargetcolval-slv-int-target-std-vector-slv-int-col-pos-std-vector-col-val-const" title="この見出しへのパーマリンク"></a></h4>
<p>指定した行の非ゼロの列位置と値をvector「col_val」にコピーします。</p>
</section>
<section id="void-printmat-const-std-string-str-mat-csv">
<h4>void printMat(const std::string&amp; str=&quot;Mat.csv&quot;)<a class="headerlink" href="#void-printmat-const-std-string-str-mat-csv" title="この見出しへのパーマリンク"></a></h4>
<p>疎行列の内容をstrで指定したファイルに書き出します。</p>
</section>
<section id="void-print">
<h4>void print()<a class="headerlink" href="#void-print" title="この見出しへのパーマリンク"></a></h4>
<p>疎行列をコンソールに表示します。</p>
</section>
</section>
<hr class="docutils" />
<section id="id4">
<h3>* オペレータ群<a class="headerlink" href="#id4" title="この見出しへのパーマリンク"></a></h3>
<hr class="docutils" />
<section id="double-operator-const-double-vec-const">
<h4>double* operator*(const double* vec) const;<a class="headerlink" href="#double-operator-const-double-vec-const" title="この見出しへのパーマリンク"></a></h4>
</section>
<section id="dcomplex-operator-const-dcomplex-vec-const">
<h4>dcomplex* operator*(const dcomplex* vec) const;<a class="headerlink" href="#dcomplex-operator-const-dcomplex-vec-const" title="この見出しへのパーマリンク"></a></h4>
<p>疎行列に列ベクトルvecを掛けて、結果ベクトルを返します。
列ベクトルはC++のデフォルトの配列で渡します。
（vecは実数、複素数どちらでも対応）</p>
</section>
<section id="eigen-vectorxd-operator-const-eigen-vectorxd-vec-const">
<h4>Eigen::VectorXd operator*(const Eigen::VectorXd&amp; vec) const;<a class="headerlink" href="#eigen-vectorxd-operator-const-eigen-vectorxd-vec-const" title="この見出しへのパーマリンク"></a></h4>
</section>
<section id="eigen-vectorxcd-operator-const-eigen-vectorxcd-vec-const">
<h4>Eigen::VectorXcd operator*(const Eigen::VectorXcd&amp; vec) const;<a class="headerlink" href="#eigen-vectorxcd-operator-const-eigen-vectorxcd-vec-const" title="この見出しへのパーマリンク"></a></h4>
<p>疎行列に列ベクトルvecを掛けて、結果ベクトルを返します。
列ベクトルはEigenのVectorで渡します。
（vecは実数、複素数どちらでも対応）</p>
</section>
<section id="void-operator-const-double-x">
<h4>void operator*=(const double x)<a class="headerlink" href="#void-operator-const-double-x" title="この見出しへのパーマリンク"></a></h4>
<p>自身の全要素にxを掛けます。</p>
</section>
<section id="sparsemat-operator-const-double-x-const">
<h4>SparseMat operator*(const double x) const;<a class="headerlink" href="#sparsemat-operator-const-double-x-const" title="この見出しへのパーマリンク"></a></h4>
</section>
<section id="sparsematc-operator-const-dcomplex-x-const">
<h4>SparseMatC operator*(const dcomplex x) const;<a class="headerlink" href="#sparsematc-operator-const-dcomplex-x-const" title="この見出しへのパーマリンク"></a></h4>
<p>自身の全要素にxを掛けた後の疎行列を返します。
（実数、複素数どちらでも対応）</p>
</section>
<section id="sparsemat-operator-const-sparsemat-mat-const">
<h4>SparseMat operator*(const SparseMat&amp; mat) const;<a class="headerlink" href="#sparsemat-operator-const-sparsemat-mat-const" title="この見出しへのパーマリンク"></a></h4>
</section>
<section id="sparsematc-operator-const-sparsematc-mat-const">
<h4>SparseMatC operator*(const SparseMatC&amp; mat) const;<a class="headerlink" href="#sparsematc-operator-const-sparsematc-mat-const" title="この見出しへのパーマリンク"></a></h4>
<p>自身と行列matの行列積を行い、結果の疎行列を返します。</p>
</section>
<section id="id5">
<h4>SparseMat operator+(const SparseMat&amp; mat) const;<a class="headerlink" href="#id5" title="この見出しへのパーマリンク"></a></h4>
</section>
<section id="id6">
<h4>SparseMatC operator+(const SparseMatC&amp; mat) const;<a class="headerlink" href="#id6" title="この見出しへのパーマリンク"></a></h4>
<p>自身と行列matを足し、結果の疎行列を返します。</p>
</section>
</section>
<hr class="docutils" />
<section id="id7">
<h3>* その他の行列オペレータ群<a class="headerlink" href="#id7" title="この見出しへのパーマリンク"></a></h3>
<hr class="docutils" />
<section id="sparsemat-trans-const">
<h4>SparseMat trans() const<a class="headerlink" href="#sparsemat-trans-const" title="この見出しへのパーマリンク"></a></h4>
<p>自身の転置行列を返します。</p>
</section>
<section id="sparsemat-makesubmat-slv-int-range1a-slv-int-range1b-slv-int-range2a-slv-int-range2b">
<h4>SparseMat makeSubMat(slv_int range1a, slv_int range1b, slv_int range2a, slv_int range2b)<a class="headerlink" href="#sparsemat-makesubmat-slv-int-range1a-slv-int-range1b-slv-int-range2a-slv-int-range2b" title="この見出しへのパーマリンク"></a></h4>
<p>範囲[r1a, r1b]×[r2a, r2b]の部分を抜き出して部分行列を作り、得られた部分行列を返します。</p>
</section>
<section id="void-matdiv-sparsemat-matk11-sparsemat-matk12-slv-int-rangea-slv-int-rangeb">
<h4>void MatDiv(SparseMat&amp; matK11, SparseMat&amp; matK12, slv_int rangeA, slv_int rangeB)<a class="headerlink" href="#void-matdiv-sparsemat-matk11-sparsemat-matk12-slv-int-rangea-slv-int-rangeb" title="この見出しへのパーマリンク"></a></h4>
<p>列rangeBを境に、行列を2つに分け、行rangeAより下は削除します。</p>
</section>
<section id="sparsemat-getmatlower-const">
<h4>SparseMat getMatLower() const;<a class="headerlink" href="#sparsemat-getmatlower-const" title="この見出しへのパーマリンク"></a></h4>
<p>下三角行列を作成して返します。</p>
</section>
<section id="sparsemat-getmatupper-const">
<h4>SparseMat getMatUpper() const<a class="headerlink" href="#sparsemat-getmatupper-const" title="この見出しへのパーマリンク"></a></h4>
<p>上三角行列を作成して返します。</p>
</section>
<section id="sparsemat-inv-const">
<h4>SparseMat inv() const<a class="headerlink" href="#sparsemat-inv-const" title="この見出しへのパーマリンク"></a></h4>
<p>逆行列（密アルゴリズム・大行列でやるとメモリが吹き飛ぶ！）</p>
</section>
<section id="void-round">
<h4>void round()<a class="headerlink" href="#void-round" title="この見出しへのパーマリンク"></a></h4>
<p>行列の要素を四捨五入して丸めます。</p>
</section>
</section>
</section>
<hr class="docutils" />
<section id="sparsematc">
<h2>SparseMatCクラス<a class="headerlink" href="#sparsematc" title="この見出しへのパーマリンク"></a></h2>
<p>複素数用の疎行列クラスです。
基本的な操作は全て実数用のSparseMatと同じです。
「SparseMat/SparseMatC.hpp」をインクルードして使ってください。</p>
</section>
<hr class="docutils" />
<section id="sparsematoperators">
<h2>SparseMatOperatorsクラス<a class="headerlink" href="#sparsematoperators" title="この見出しへのパーマリンク"></a></h2>
<p>複数の疎行列の操作を行うstaticなメソッドを管理するクラスです。
「SparseMat/SparseMatOperators.hpp」をインクルードして使ってください。</p>
<section id="static-sparsemat-plusshift-const-sparsemat-mat1-const-sparsemat-mat2-const-double-a1-const-double-a2-const-slv-int-pos1-const-slv-int-pos2">
<h3>static SparseMat plusShift(const SparseMat&amp; mat1, const SparseMat&amp; mat2, const double a1, const double a2, const slv_int pos1, const slv_int pos2)<a class="headerlink" href="#static-sparsemat-plusshift-const-sparsemat-mat1-const-sparsemat-mat2-const-double-a1-const-double-a2-const-slv-int-pos1-const-slv-int-pos2" title="この見出しへのパーマリンク"></a></h3>
</section>
<section id="static-sparsematc-plusshift-const-sparsematc-mat1-const-sparsematc-mat2-const-double-a1-const-double-a2-const-slv-int-pos1-const-slv-int-pos2">
<h3>static SparseMatC plusShift(const SparseMatC&amp; mat1, const SparseMatC&amp; mat2, const double a1, const double a2, const slv_int pos1, const slv_int pos2)<a class="headerlink" href="#static-sparsematc-plusshift-const-sparsematc-mat1-const-sparsematc-mat2-const-double-a1-const-double-a2-const-slv-int-pos1-const-slv-int-pos2" title="この見出しへのパーマリンク"></a></h3>
<p>(a1<em>mat1 + a2</em>mat2)を計算して、結果の疎行列を返します。
mat2に足す位置をpos1,pos2でずらすことが可能です。</p>
</section>
<section id="static-double-dotvecmat2-const-sparsemat-mat1-const-sparsemat-mat2-const-double-vec1">
<h3>static double* dotVecMat2(const SparseMat&amp; mat1, const SparseMat&amp; mat2, const double* vec1);<a class="headerlink" href="#static-double-dotvecmat2-const-sparsemat-mat1-const-sparsemat-mat2-const-double-vec1" title="この見出しへのパーマリンク"></a></h3>
</section>
<section id="static-dcomplex-dotvecmat2-const-sparsemat-mat1-const-sparsematc-mat2-const-double-vec1">
<h3>static dcomplex* dotVecMat2(const SparseMat&amp; mat1, const SparseMatC&amp; mat2, const double* vec1);<a class="headerlink" href="#static-dcomplex-dotvecmat2-const-sparsemat-mat1-const-sparsematc-mat2-const-double-vec1" title="この見出しへのパーマリンク"></a></h3>
</section>
<section id="static-dcomplex-dotvecmat2-const-sparsematc-mat1-const-sparsemat-mat2-const-double-vec1">
<h3>static dcomplex* dotVecMat2(const SparseMatC&amp; mat1, const SparseMat&amp; mat2, const double* vec1);<a class="headerlink" href="#static-dcomplex-dotvecmat2-const-sparsematc-mat1-const-sparsemat-mat2-const-double-vec1" title="この見出しへのパーマリンク"></a></h3>
</section>
<section id="static-dcomplex-dotvecmat2-const-sparsematc-mat1-const-sparsematc-mat2-const-double-vec1">
<h3>static dcomplex* dotVecMat2(const SparseMatC&amp; mat1, const SparseMatC&amp; mat2, const double* vec1);<a class="headerlink" href="#static-dcomplex-dotvecmat2-const-sparsematc-mat1-const-sparsematc-mat2-const-double-vec1" title="この見出しへのパーマリンク"></a></h3>
</section>
<section id="static-dcomplex-dotvecmat2-const-sparsemat-mat1-const-sparsemat-mat2-const-dcomplex-vec1">
<h3>static dcomplex* dotVecMat2(const SparseMat&amp; mat1, const SparseMat&amp; mat2, const dcomplex* vec1);<a class="headerlink" href="#static-dcomplex-dotvecmat2-const-sparsemat-mat1-const-sparsemat-mat2-const-dcomplex-vec1" title="この見出しへのパーマリンク"></a></h3>
</section>
<section id="static-dcomplex-dotvecmat2-const-sparsemat-mat1-const-sparsematc-mat2-const-dcomplex-vec1">
<h3>static dcomplex* dotVecMat2(const SparseMat&amp; mat1, const SparseMatC&amp; mat2, const dcomplex* vec1);<a class="headerlink" href="#static-dcomplex-dotvecmat2-const-sparsemat-mat1-const-sparsematc-mat2-const-dcomplex-vec1" title="この見出しへのパーマリンク"></a></h3>
</section>
<section id="static-dcomplex-dotvecmat2-const-sparsematc-mat1-const-sparsemat-mat2-const-dcomplex-vec1">
<h3>static dcomplex* dotVecMat2(const SparseMatC&amp; mat1, const SparseMat&amp; mat2, const dcomplex* vec1);<a class="headerlink" href="#static-dcomplex-dotvecmat2-const-sparsematc-mat1-const-sparsemat-mat2-const-dcomplex-vec1" title="この見出しへのパーマリンク"></a></h3>
</section>
<section id="static-dcomplex-dotvecmat2-const-sparsematc-mat1-const-sparsematc-mat2-const-dcomplex-vec1">
<h3>static dcomplex* dotVecMat2(const SparseMatC&amp; mat1, const SparseMatC&amp; mat2, const dcomplex* vec1);<a class="headerlink" href="#static-dcomplex-dotvecmat2-const-sparsematc-mat1-const-sparsematc-mat2-const-dcomplex-vec1" title="この見出しへのパーマリンク"></a></h3>
<p>(mat1 + mat2)*vecBを計算し、得られたベクトルを返します。</p>
</section>
<section id="static-sparsemat-dotmats-const-sparsemat-mata-const-sparsemat-matb-const-sparsemat-matc">
<h3>static SparseMat dotMats(const SparseMat&amp; matA, const SparseMat&amp; matB, const SparseMat&amp; matC);<a class="headerlink" href="#static-sparsemat-dotmats-const-sparsemat-mata-const-sparsemat-matb-const-sparsemat-matc" title="この見出しへのパーマリンク"></a></h3>
</section>
<section id="static-sparsematc-dotmats-const-sparsemat-mata-const-sparsemat-matb-const-sparsematc-matc">
<h3>static SparseMatC dotMats(const SparseMat&amp; matA, const SparseMat&amp; matB, const SparseMatC&amp; matC);<a class="headerlink" href="#static-sparsematc-dotmats-const-sparsemat-mata-const-sparsemat-matb-const-sparsematc-matc" title="この見出しへのパーマリンク"></a></h3>
</section>
<section id="static-sparsematc-dotmats-const-sparsemat-mata-const-sparsematc-matb-const-sparsematc-matc">
<h3>static SparseMatC dotMats(const SparseMat&amp; matA, const SparseMatC&amp; matB, const SparseMatC&amp; matC);<a class="headerlink" href="#static-sparsematc-dotmats-const-sparsemat-mata-const-sparsematc-matb-const-sparsematc-matc" title="この見出しへのパーマリンク"></a></h3>
</section>
<section id="static-sparsematc-dotmats-const-sparsematc-mata-const-sparsematc-matb-const-sparsematc-matc">
<h3>static SparseMatC dotMats(const SparseMatC&amp; matA, const SparseMatC&amp; matB, const SparseMatC&amp; matC);<a class="headerlink" href="#static-sparsematc-dotmats-const-sparsematc-mata-const-sparsematc-matb-const-sparsematc-matc" title="この見出しへのパーマリンク"></a></h3>
<p>疎行列AとBとCをかけて結果を返します。</p>
</section>
<section id="static-void-plusfix-sparsemat-matab-const-sparsemat-mata-const-sparsemat-matb-double-a1-1-0-double-a2-1-0-slv-int-pos1-0-slv-int-pos2-0">
<h3>static void plusFix(SparseMat&amp; matAB, const SparseMat&amp; matA, const SparseMat&amp; matB, double a1=1.0, double a2=1.0, slv_int pos1=0, slv_int pos2=0);<a class="headerlink" href="#static-void-plusfix-sparsemat-matab-const-sparsemat-mata-const-sparsemat-matb-double-a1-1-0-double-a2-1-0-slv-int-pos1-0-slv-int-pos2-0" title="この見出しへのパーマリンク"></a></h3>
</section>
<section id="static-void-plusfix-sparsematc-matab-const-sparsemat-mata-const-sparsematc-matb-double-a1-1-0-double-a2-1-0-slv-int-pos1-0-slv-int-pos2-0">
<h3>static void plusFix(SparseMatC&amp; matAB, const SparseMat&amp; matA, const SparseMatC&amp; matB, double a1=1.0, double a2=1.0, slv_int pos1=0, slv_int pos2=0);<a class="headerlink" href="#static-void-plusfix-sparsematc-matab-const-sparsemat-mata-const-sparsematc-matb-double-a1-1-0-double-a2-1-0-slv-int-pos1-0-slv-int-pos2-0" title="この見出しへのパーマリンク"></a></h3>
</section>
<section id="static-void-plusfix-sparsematc-matab-const-sparsematc-mata-const-sparsematc-matb-double-a1-1-0-double-a2-1-0-slv-int-pos1-0-slv-int-pos2-0">
<h3>static void plusFix(SparseMatC&amp; matAB, const SparseMatC&amp; matA, const SparseMatC&amp; matB, double a1=1.0, double a2=1.0, slv_int pos1=0, slv_int pos2=0);<a class="headerlink" href="#static-void-plusfix-sparsematc-matab-const-sparsematc-mata-const-sparsematc-matb-double-a1-1-0-double-a2-1-0-slv-int-pos1-0-slv-int-pos2-0" title="この見出しへのパーマリンク"></a></h3>
<p>fix済みの行列matABCに、(a1<em>matA+a2</em>matB)の結果を代入します。
matBの開始位置はposだけずらすことが可能です。</p>
</section>
<section id="static-void-plusfix-sparsemat-matabc-const-sparsemat-mata-const-sparsemat-matb-const-sparsemat-matc-double-a1-1-0-double-a2-1-0-double-a3-1-0">
<h3>static void plusFix(SparseMat&amp; matABC, const SparseMat&amp; matA, const SparseMat&amp; matB, const SparseMat&amp; matC, double a1=1.0, double a2=1.0, double a3=1.0);<a class="headerlink" href="#static-void-plusfix-sparsemat-matabc-const-sparsemat-mata-const-sparsemat-matb-const-sparsemat-matc-double-a1-1-0-double-a2-1-0-double-a3-1-0" title="この見出しへのパーマリンク"></a></h3>
</section>
<section id="static-void-plusfix-sparsematc-matabc-const-sparsematc-mata-const-sparsematc-matb-const-sparsematc-matc-double-a1-1-0-double-a2-1-0-double-a3-1-0">
<h3>static void plusFix(SparseMatC&amp; matABC, const SparseMatC&amp; matA, const SparseMatC&amp; matB, const SparseMatC&amp; matC, double a1=1.0, double a2=1.0, double a3=1.0);<a class="headerlink" href="#static-void-plusfix-sparsematc-matabc-const-sparsematc-mata-const-sparsematc-matb-const-sparsematc-matc-double-a1-1-0-double-a2-1-0-double-a3-1-0" title="この見出しへのパーマリンク"></a></h3>
<p>fix済みの行列matABCに、(a1<em>A+a2</em>B+a3*C)の結果を代入します。</p>
</section>
<section id="static-void-dotfix-sparsemat-matab-const-sparsemat-mata-const-sparsemat-matb">
<h3>static void dotFix(SparseMat&amp; matAB, const SparseMat&amp; matA, const SparseMat&amp; matB);<a class="headerlink" href="#static-void-dotfix-sparsemat-matab-const-sparsemat-mata-const-sparsemat-matb" title="この見出しへのパーマリンク"></a></h3>
</section>
<section id="static-void-dotfix-sparsematc-matab-const-sparsemat-mata-const-sparsematc-matb">
<h3>static void dotFix(SparseMatC&amp; matAB, const SparseMat&amp; matA, const SparseMatC&amp; matB);<a class="headerlink" href="#static-void-dotfix-sparsematc-matab-const-sparsemat-mata-const-sparsematc-matb" title="この見出しへのパーマリンク"></a></h3>
</section>
<section id="static-void-dotfix-sparsematc-matab-const-sparsematc-mata-const-sparsematc-matb">
<h3>static void dotFix(SparseMatC&amp; matAB, const SparseMatC&amp; matA, const SparseMatC&amp; matB);<a class="headerlink" href="#static-void-dotfix-sparsematc-matab-const-sparsematc-mata-const-sparsematc-matb" title="この見出しへのパーマリンク"></a></h3>
<p>fix済みの行列matABCに、AとBの行列積の結果を代入します。</p>
</section>
<section id="static-void-dotfix-sparsemat-matab-const-sparsemat-mata-const-sparsemat-matb-const-sparsemat-matc">
<h3>static void dotFix(SparseMat&amp; matAB, const SparseMat&amp; matA, const SparseMat&amp; matB, const SparseMat&amp; matC);<a class="headerlink" href="#static-void-dotfix-sparsemat-matab-const-sparsemat-mata-const-sparsemat-matb-const-sparsemat-matc" title="この見出しへのパーマリンク"></a></h3>
</section>
<section id="static-void-dotfix-sparsematc-matab-const-sparsemat-mata-const-sparsemat-matb-const-sparsematc-matc">
<h3>static void dotFix(SparseMatC&amp; matAB, const SparseMat&amp; matA, const SparseMat&amp; matB, const SparseMatC&amp; matC);<a class="headerlink" href="#static-void-dotfix-sparsematc-matab-const-sparsemat-mata-const-sparsemat-matb-const-sparsematc-matc" title="この見出しへのパーマリンク"></a></h3>
</section>
<section id="static-void-dotfix-sparsematc-matab-const-sparsemat-mata-const-sparsematc-matb-const-sparsematc-matc">
<h3>static void dotFix(SparseMatC&amp; matAB, const SparseMat&amp; matA, const SparseMatC&amp; matB, const SparseMatC&amp; matC);<a class="headerlink" href="#static-void-dotfix-sparsematc-matab-const-sparsemat-mata-const-sparsematc-matb-const-sparsematc-matc" title="この見出しへのパーマリンク"></a></h3>
</section>
<section id="static-void-dotfix-sparsematc-matab-const-sparsematc-mata-const-sparsematc-matb-const-sparsematc-matc">
<h3>static void dotFix(SparseMatC&amp; matAB, const SparseMatC&amp; matA, const SparseMatC&amp; matB, const SparseMatC&amp; matC);<a class="headerlink" href="#static-void-dotfix-sparsematc-matab-const-sparsematc-mata-const-sparsematc-matb-const-sparsematc-matc" title="この見出しへのパーマリンク"></a></h3>
<p>fix済みの行列matABCに、AとBとCの行列積の結果を代入します。</p>
</section>
</section>
<hr class="docutils" />
<section id="matsolvers">
<h2>MatSolversクラス<a class="headerlink" href="#matsolvers" title="この見出しへのパーマリンク"></a></h2>
<p>疎行列用のソルバを提供するクラスです。全てstaticメソッドです。
「SparseMat/MatSolvers.hpp」をインクルードして使ってください。</p>
<section id="id8">
<h3>static SparseMat plusShift(const SparseMat&amp; mat1, const SparseMat&amp; mat2, const double a1, const double a2, const slv_int pos1, const slv_int pos2)<a class="headerlink" href="#id8" title="この見出しへのパーマリンク"></a></h3>
</section>
<section id="id9">
<h3>static SparseMatC plusShift(const SparseMatC&amp; mat1, const SparseMatC&amp; mat2, const double a1, const double a2, const slv_int pos1, const slv_int pos2)<a class="headerlink" href="#id9" title="この見出しへのパーマリンク"></a></h3>
<p>(a1<em>mat1 + a2</em>mat2)を計算して、結果の疎行列を返します。
mat2に足す位置をpos1,pos2でずらすことが可能です。</p>
</section>
<section id="static-bool-solveiccg-const-slv-int-size0-const-double-conv-cri-const-int-max-ite-const-double-accera-const-sparsemat-mata-const-double-vecb-double-results-bool-init-false">
<h3>static bool solveICCG(const slv_int size0, const double conv_cri, const int max_ite, const double accera, const SparseMat&amp; matA, const double *vecB, double *results, bool init=false)<a class="headerlink" href="#static-bool-solveiccg-const-slv-int-size0-const-double-conv-cri-const-int-max-ite-const-double-accera-const-sparsemat-mata-const-double-vecb-double-results-bool-init-false" title="この見出しへのパーマリンク"></a></h3>
</section>
<section id="static-bool-solveiccg-const-slv-int-size0-const-double-conv-cri-const-int-max-ite-const-double-accera-const-double-normb-const-sparsemat-mata-const-double-vecb-double-results-bool-init-false">
<h3>static bool solveICCG(const slv_int size0, const double conv_cri, const int max_ite, const double accera, const double normB, const SparseMat&amp; matA, const double *vecB, double *results, bool init=false)<a class="headerlink" href="#static-bool-solveiccg-const-slv-int-size0-const-double-conv-cri-const-int-max-ite-const-double-accera-const-double-normb-const-sparsemat-mata-const-double-vecb-double-results-bool-init-false" title="この見出しへのパーマリンク"></a></h3>
</section>
<section id="static-bool-solveiccg-const-slv-int-size0-const-double-conv-cri-const-int-max-ite-const-double-accera-const-sparsemat-mata-const-eigen-vectorxd-vecb-double-results-bool-init-false">
<h3>static bool solveICCG(const slv_int size0, const double conv_cri, const int max_ite, const double accera, const SparseMat&amp; matA, const Eigen::VectorXd&amp; vecB, double *results, bool init=false)<a class="headerlink" href="#static-bool-solveiccg-const-slv-int-size0-const-double-conv-cri-const-int-max-ite-const-double-accera-const-sparsemat-mata-const-eigen-vectorxd-vecb-double-results-bool-init-false" title="この見出しへのパーマリンク"></a></h3>
<p>自作のICCG法です。右辺をC++配列、Eigen::VectorXdで与えるかで2パターンあります。
また、引く数normBは、右辺bのノルムを事前に与えるか、内部で計算するかです。
（normBは、収束判定で使います。&quot;r/normB &lt; conv_cri&quot;となると収束とします。）</p>
<p>size0：行列の行数です。
conv_cri：収束判定値です。10^-6など。
max_ite：最大反復数です。
accera：加速係数です。
matA：Ax=bのAです。対称行列としてください。
vecB:Ax=bのbです。size0のベクトルです。
results：解ベクトルです（Ax=bのx）。メモリは事前にsize0だけ確保しておいてください。
init：解ベクトルxをこの処理の前にゼロ初期化するかです。過去の値がxに入っていて流用したい場合はfalseにしてください。それ以外はtrueにすれば内部でゼロ初期化してから始めます。</p>
</section>
<section id="static-bool-solveiccg-slv-int-size0-const-double-conv-cri-const-int-max-ite-const-double-accera-const-sparsematc-mata-const-dcomplex-vecb-dcomplex-results-bool-init-false">
<h3>static bool solveICCG(slv_int size0, const double conv_cri, const int max_ite, const double accera, const SparseMatC&amp; matA, const dcomplex *vecB, dcomplex *results, bool init=false);<a class="headerlink" href="#static-bool-solveiccg-slv-int-size0-const-double-conv-cri-const-int-max-ite-const-double-accera-const-sparsematc-mata-const-dcomplex-vecb-dcomplex-results-bool-init-false" title="この見出しへのパーマリンク"></a></h3>
</section>
<section id="static-bool-solveiccg-slv-int-size0-const-double-conv-cri-const-int-max-ite-const-double-accera-const-double-normb-const-sparsematc-mata-const-dcomplex-vecb-dcomplex-results-bool-init-false">
<h3>static bool solveICCG(slv_int size0, const double conv_cri, const int max_ite, const double accera, const double normB, const SparseMatC&amp; matA, const dcomplex *vecB, dcomplex *results, bool init=false);<a class="headerlink" href="#static-bool-solveiccg-slv-int-size0-const-double-conv-cri-const-int-max-ite-const-double-accera-const-double-normb-const-sparsematc-mata-const-dcomplex-vecb-dcomplex-results-bool-init-false" title="この見出しへのパーマリンク"></a></h3>
</section>
<section id="static-bool-solveiccg-slv-int-size0-const-double-conv-cri-const-int-max-ite-const-double-accera-const-sparsematc-mata-const-eigen-vectorxcd-vecb-dcomplex-results-bool-init-false">
<h3>static bool solveICCG(slv_int size0, const double conv_cri, const int max_ite, const double accera, const SparseMatC&amp; matA, const Eigen::VectorXcd&amp; vecB, dcomplex *results, bool init=false);<a class="headerlink" href="#static-bool-solveiccg-slv-int-size0-const-double-conv-cri-const-int-max-ite-const-double-accera-const-sparsematc-mata-const-eigen-vectorxcd-vecb-dcomplex-results-bool-init-false" title="この見出しへのパーマリンク"></a></h3>
<p>上記ICCG法の複素数版です。使い方は同じです。
ただしmatAは対称行列にのみ対応しています（エルミートなどは未対応）</p>
</section>
<section id="static-bool-solveeigeniccg-const-slv-int-size0-const-double-conv-cri-const-int-max-ite-const-sparsemat-mata-const-eigen-vectorxd-vecb-eigen-vectorxd-results-bool-init-false">
<h3>static bool solveEigenICCG(const slv_int size0, const double conv_cri, const int max_ite, const SparseMat&amp; matA, const Eigen::VectorXd&amp; vecB, Eigen::VectorXd&amp; results, bool init=false);<a class="headerlink" href="#static-bool-solveeigeniccg-const-slv-int-size0-const-double-conv-cri-const-int-max-ite-const-sparsemat-mata-const-eigen-vectorxd-vecb-eigen-vectorxd-results-bool-init-false" title="この見出しへのパーマリンク"></a></h3>
</section>
<section id="static-bool-solveeigeniccg-const-slv-int-size0-const-double-conv-cri-const-int-max-ite-const-sparsemat-mata-const-double-vecb-double-results-bool-init-true">
<h3>static bool solveEigenICCG(const slv_int size0, const double conv_cri, const int max_ite, const SparseMat&amp; matA, const double* vecB, double* results, bool init=true);<a class="headerlink" href="#static-bool-solveeigeniccg-const-slv-int-size0-const-double-conv-cri-const-int-max-ite-const-sparsemat-mata-const-double-vecb-double-results-bool-init-true" title="この見出しへのパーマリンク"></a></h3>
</section>
<section id="static-bool-solveeigenbicgstab-const-slv-int-size0-const-double-conv-cri-const-int-max-ite-const-sparsemat-mata-const-eigen-vectorxd-vecb-eigen-vectorxd-results-bool-init-false">
<h3>static bool solveEigenBiCGstab(const slv_int size0, const double conv_cri, const int max_ite, const SparseMat&amp; matA, const Eigen::VectorXd&amp; vecB, Eigen::VectorXd&amp; results, bool init=false);<a class="headerlink" href="#static-bool-solveeigenbicgstab-const-slv-int-size0-const-double-conv-cri-const-int-max-ite-const-sparsemat-mata-const-eigen-vectorxd-vecb-eigen-vectorxd-results-bool-init-false" title="この見出しへのパーマリンク"></a></h3>
</section>
<section id="static-bool-solveeigenbicgstab-const-slv-int-size0-const-double-conv-cri-const-int-max-ite-const-sparsemat-mata-const-double-vecb-double-results-bool-init-true">
<h3>static bool solveEigenBiCGstab(const slv_int size0, const double conv_cri, const int max_ite, const SparseMat&amp; matA, const double* vecB, double* results, bool init=true);<a class="headerlink" href="#static-bool-solveeigenbicgstab-const-slv-int-size0-const-double-conv-cri-const-int-max-ite-const-sparsemat-mata-const-double-vecb-double-results-bool-init-true" title="この見出しへのパーマリンク"></a></h3>
</section>
<section id="static-bool-solveeigeniccg-const-slv-int-size0-const-double-conv-cri-const-int-max-ite-const-sparsematc-mata-const-eigen-vectorxcd-vecb-eigen-vectorxcd-results-bool-init-false">
<h3>static bool solveEigenICCG(const slv_int size0, const double conv_cri, const int max_ite, const SparseMatC&amp; matA, const Eigen::VectorXcd&amp; vecB, Eigen::VectorXcd&amp; results, bool init=false);<a class="headerlink" href="#static-bool-solveeigeniccg-const-slv-int-size0-const-double-conv-cri-const-int-max-ite-const-sparsematc-mata-const-eigen-vectorxcd-vecb-eigen-vectorxcd-results-bool-init-false" title="この見出しへのパーマリンク"></a></h3>
</section>
<section id="static-bool-solveeigeniccg-const-slv-int-size0-const-double-conv-cri-const-int-max-ite-const-sparsematc-mata-const-dcomplex-vecb-dcomplex-results-bool-init-true">
<h3>static bool solveEigenICCG(const slv_int size0, const double conv_cri, const int max_ite, const SparseMatC&amp; matA, const dcomplex* vecB, dcomplex* results, bool init=true);<a class="headerlink" href="#static-bool-solveeigeniccg-const-slv-int-size0-const-double-conv-cri-const-int-max-ite-const-sparsematc-mata-const-dcomplex-vecb-dcomplex-results-bool-init-true" title="この見出しへのパーマリンク"></a></h3>
</section>
<section id="static-bool-solveeigenbicgstab-const-slv-int-size0-const-double-conv-cri-const-int-max-ite-const-sparsematc-mata-const-eigen-vectorxcd-vecb-eigen-vectorxcd-results-bool-init-false">
<h3>static bool solveEigenBiCGstab(const slv_int size0, const double conv_cri, const int max_ite, const SparseMatC&amp; matA, const Eigen::VectorXcd&amp; vecB, Eigen::VectorXcd&amp; results, bool init=false);<a class="headerlink" href="#static-bool-solveeigenbicgstab-const-slv-int-size0-const-double-conv-cri-const-int-max-ite-const-sparsematc-mata-const-eigen-vectorxcd-vecb-eigen-vectorxcd-results-bool-init-false" title="この見出しへのパーマリンク"></a></h3>
</section>
<section id="static-bool-solveeigenbicgstab-const-slv-int-size0-const-double-conv-cri-const-int-max-ite-const-sparsematc-mata-const-dcomplex-vecb-dcomplex-results-bool-init-false">
<h3>static bool solveEigenBiCGstab(const slv_int size0, const double conv_cri, const int max_ite, const SparseMatC&amp; matA,  const dcomplex* vecB, dcomplex* results, bool init=false);<a class="headerlink" href="#static-bool-solveeigenbicgstab-const-slv-int-size0-const-double-conv-cri-const-int-max-ite-const-sparsematc-mata-const-dcomplex-vecb-dcomplex-results-bool-init-false" title="この見出しへのパーマリンク"></a></h3>
<p>Eigenに付属している疎行列ソルバのラッパーです。
使い方は上記ICCG法の引数と同じです。</p>
</section>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="BaseLibraries.html" class="btn btn-neutral float-left" title="BasicFuncs" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="UserSample.html" class="btn btn-neutral float-right" title="利用例" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2022, JP-MARs.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>